<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Manifest" xml:space="preserve">
    <value>Название программы: Grapher (исследователь функций)
Версия: 1.0.0

Это приложение предназначено для выполнения
математических расчетов и визуализации графиков.
Вы можете использовать его для анализа функций и
получения различных решений.

Разработано студенткой группы 21 П-1,
Семакиной Ладой Владиславовной.

Все права защищены.
2024 г.</value>
  </data>
  <data name="ODU_ADAMS" xml:space="preserve">
    <value>Многошаговые Методы (Методы Адамса)

Идея:

В отличие от одношаговых методов (Эйлер, Рунге-Кутта), которые для вычисления yᵢ₊₁ используют информацию только из предыдущей точки (xᵢ, yᵢ), многошаговые методы используют значения решения y и/или его производной f в нескольких предыдущих точках (yᵢ, yᵢ₋₁, yᵢ₋₂, ... и fᵢ, fᵢ₋₁, fᵢ₋₂, ...). Они основаны на идее аппроксимации интеграла ∫ f(x, y) dx с помощью интерполяционного полинома, построенного по предыдущим значениям f.

Типы Методов Адамса:

Методы Адамса-Башфорта (Явные):
 - Используют интерполяционный полином, построенный по точкам (xᵢ, fᵢ), (xᵢ₋₁, fᵢ₋₁), ..., (xᵢ₋ₖ₊₁, fᵢ₋ₖ₊₁), чтобы экстраполировать значение f на интервале [xᵢ, xᵢ₊₁].
 - Формула для yᵢ₊₁ зависит только от известных предыдущих значений y и f.
 - Пример (Адамс-Башфорт 4-го порядка, AB4): yᵢ₊₁ = yᵢ + h/24 * (55*fᵢ - 59*fᵢ₋₁ + 37*fᵢ₋₂ - 9*fᵢ₋₃) где fⱼ = f(xⱼ, yⱼ).
 - Проблема "старта": Для вычисления y₄ по этой формуле нужны y₃, f₃, f₂, f₁, f₀. Первые несколько точек (y₁, y₂, y₃) нужно вычислить другим методом (например, Рунге-Кутты 4-го порядка).

Методы Адамса-Мультона (Неявные):
 - Используют интерполяционный полином, построенный по точкам (xᵢ₊₁, fᵢ₊₁), (xᵢ, fᵢ), ..., (xᵢ₋ₖ₊₁, fᵢ₋ₖ₊₁). То есть, полином включает будущую неизвестную точку.
 - Формула для yᵢ₊₁ содержит f(xᵢ₊₁, yᵢ₊₁), что делает метод неявным. Требует решения алгебраического уравнения на каждом шаге (как неявный Эйлер).
 - Пример (Адамс-Мультон 4-го порядка, AM4): yᵢ₊₁ = yᵢ + h/24 * (9*fᵢ₊₁ + 19*fᵢ - 5*fᵢ₋₁ + fᵢ₋₂) где fᵢ₊₁ = f(xᵢ₊₁, yᵢ₊₁).
 - Проблема "старта": Аналогична методам Адамса-Башфорта.
Устойчивость: Обладают лучшей устойчивостью по сравнению с явными методами Адамса-Башфорта того же порядка.
Методы Адамса типа "Предиктор-Корректор":

Самый популярный подход. Комбинирует явный метод (предиктор) для получения начальной оценки ỹᵢ₊₁ и неявный метод (корректор), использующий эту оценку, для уточнения значения yᵢ₊₁. Это позволяет избежать итерационного решения неявного уравнения на каждом шаге.
Пример (Предиктор-Корректор Адамса 4-го порядка, ABM4):
 - Предиктор (AB4): Вычислить предварительное ỹᵢ₊₁: ỹᵢ₊₁ = yᵢ + h/24 * (55fᵢ - 59fᵢ₋₁ + 37fᵢ₋₂ - 9fᵢ₋₃)
 - Вычисление f: Вычислить f̃ᵢ₊₁ = f(xᵢ₊₁, ỹᵢ₊₁)
 - Корректор (AM4): Вычислить итоговое yᵢ₊₁: yᵢ₊₁ = yᵢ + h/24 * (9f̃ᵢ₊₁ + 19fᵢ - 5fᵢ₋₁ + fᵢ₋₂)
Проблема "старта": Все еще актуальна.
Эффективность: После "старта" такие методы обычно требуют меньше вычислений функции f на шаге (здесь 2 вычисления: одно на предикторе, одно на корректоре) по сравнению с методом Рунге-Кутты того же порядка (RK4 требует 4 вычисления), при этом обеспечивая схожую точность (ABM4 тоже 4-го порядка).</value>
  </data>
  <data name="ODU_AILER" xml:space="preserve">
    <value>Методы Эйлера (явный, неявный, модифицированный)
При заданном начальном условии y(x₀) = y₀. Цель — найти приближенное значение функции y(x) в последующих точках x₁, x₂, ....

1. Явный (Прямой) Метод Эйлера

Идея: Самый простой метод. Мы используем значение производной f(x, y) в начале текущего шага xᵢ, чтобы экстраполировать значение y на следующем шаге xᵢ₊₁.

Формула: yᵢ₊₁ = yᵢ + h * f(xᵢ, yᵢ) где h = xᵢ₊₁ - xᵢ — размер шага.

Характеристики:
 - Прост в реализации.
 - Метод первого порядка точности (локальная погрешность O(h²), глобальная O(h)).
 - Может быть численно неустойчивым, особенно для "жестких" ОДУ или при большом шаге h. Требуется достаточно малый шаг для приемлемой точности и устойчивости.

2. Неявный (Обратный) Метод Эйлера

Идея: Использует значение производной f(x, y) в конце текущего шага xᵢ₊₁, чтобы определить значение yᵢ₊₁.

Формула: yᵢ₊₁ = yᵢ + h * f(xᵢ₊₁, yᵢ₊₁)

Проблема: Значение yᵢ₊₁, которое мы ищем, находится в обеих частях уравнения. Если функция f(x, y) нелинейна по y, то на каждом шаге нужно решать это (обычно нелинейное) алгебраическое уравнение относительно yᵢ₊₁. Часто это делают итерационными методами (например, методом простой итерации или методом Ньютона).

Характеристики:
 - Сложнее в реализации из-за необходимости решения уравнения на каждом шаге.
 - Метод первого порядка точности (как и явный).
 - Обладает значительно лучшей численной устойчивостью (A-устойчив), хорошо подходит для жестких ОДУ, позволяет использовать больший шаг h по сравнению с явным методом без потери устойчивости (но не точности).

3. Модифицированный Метод Эйлера (Метод Эйлера-Коши, Улучшенный Метод Эйлера, Метод Хойна/Гюна)

Идея: Это метод типа "предиктор-корректор", который повышает точность. Сначала делается предсказание yᵢ₊₁ с помощью явного метода, затем вычисляется производная в этой предсказанной точке, и используется среднее арифметическое производных в начале и в (предсказанном) конце шага для финального вычисления yᵢ₊₁.

Формула (в два шага):
 - Предиктор: ỹᵢ₊₁ = yᵢ + h * f(xᵢ, yᵢ) (Предварительное значение)
 - Корректор: yᵢ₊₁ = yᵢ + (h / 2) * [f(xᵢ, yᵢ) + f(xᵢ₊₁, ỹᵢ₊₁)] (Итоговое значение)

Характеристики:
 - Относительно прост в реализации (два вычисления f(x,y) на шаге).
 - Метод второго порядка точности (локальная погрешность O(h³), глобальная O(h²)) — значительно точнее явного и неявного методов.
 - Более устойчив, чем явный метод, но менее устойчив, чем неявный. Является простейшим методом Рунге-Кутты (RK2).
</value>
  </data>
  <data name="ODU_RK" xml:space="preserve">
    <value>Как и в случае с методами Эйлера, методы Рунге-Кутты предназначены для численного решения обыкновенных дифференциальных уравнений (ОДУ) вида dy/dx = f(x, y) с начальным условием y(x₀) = y₀, а не для численного дифференцирования (нахождения производной).

Методы Рунге-Кутты — это целое семейство итерационных методов для решения ОДУ, которые стремятся достичь более высокой точности по сравнению с методами Эйлера за счет вычисления значения функции f(x, y) в нескольких промежуточных точках внутри одного шага h. Наиболее известным и широко используемым является классический метод Рунге-Кутты 4-го порядка (RK4).

Метод Рунге-Кутты 4-го Порядка (RK4)

Идея: Вместо одного вычисления наклона (как в явном Эйлере) или двух (как в модифицированном Эйлере/Хойне), метод RK4 использует четыре тщательно подобранных вычисления наклона f(x, y) внутри шага [xᵢ, xᵢ₊₁]. Эти наклоны затем комбинируются со специальными весами так, чтобы погрешность аппроксимации решения ОДУ имела порядок O(h⁵) на одном шаге (и O(h⁴) на всем интервале), что соответствует аппроксимации ряда Тейлора до члена с h⁴ включительно, но без явного вычисления производных от f(x, y).
Формулы: Для перехода от точки (xᵢ, yᵢ) к (xᵢ₊₁, yᵢ₊₁) с шагом h:
k₁ = h * f(xᵢ, yᵢ) (Наклон в начале шага)
k₂ = h * f(xᵢ + h/2, yᵢ + k₁/2) (Наклон в середине шага, используя k₁ для аппроксимации y в середине)
k₃ = h * f(xᵢ + h/2, yᵢ + k₂/2) (Еще один наклон в середине шага, но используя k₂ для аппроксимации y — обычно это более точная оценка)
k₄ = h * f(xᵢ + h, yᵢ + k₃) (Наклон в конце шага, используя k₃ для аппроксимации y в конце)
yᵢ₊₁ = yᵢ + (1/6) * (k₁ + 2k₂ + 2k₃ + k₄) (Итоговое значение y как взвешенное среднее вычисленных наклонов)
xᵢ₊₁ = xᵢ + h
Характеристики:
Очень популярный метод благодаря отличному балансу между точностью, устойчивостью и сложностью реализации.
Метод четвертого порядка точности (глобальная погрешность O(h⁴)). Значительно точнее методов Эйлера при том же шаге h.
Обладает хорошими свойствами устойчивости для большинства нежестких ОДУ.


При решении dy/dx = x + y, y(0)=1 до x=1 с шагов = 10:

Явный Эйлер: y(1.00) = 3.187485
Неявный Эйлер: y(1.00) = 3.195919
Модифицированный Эйлер: y(1.00) = 3.419156
Рунге-Кутта 4: y(1.00) = 3.43655960
Аналитическое: y(1.00) = 3.43656366
Как видите, метод Рунге-Кутты 4-го порядка даже при небольшом количестве шагов (n=10) дает результат, очень близкий к точному и значительно превосходящий по точности все три варианта метода Эйлера при том же n. Это делает RK4 очень популярным выбором для решения широкого круга ОДУ, не являющихся слишком "жесткими".</value>
  </data>
  <data name="SLAU_GAUSS" xml:space="preserve">
    <value>Метод Гаусса — это классический и один из самых универсальных прямых методов решения СЛАУ вида Ax = b, где A — матрица коэффициентов системы, x — вектор неизвестных, а b — вектор свободных членов.

Суть метода заключается в последовательном исключении неизвестных из уравнений системы с помощью элементарных преобразований над строками расширенной матрицы системы. Цель — привести исходную систему к эквивалентной системе с матрицей более простого вида (обычно треугольной или ступенчатой), из которой неизвестные легко находятся последовательной подстановкой.

Элементарные преобразования строк включают:

Перестановка строк: Изменение порядка уравнений в системе.
Умножение строки на ненулевое число: Умножение обеих частей одного из уравнений на одно и то же ненулевое число.
Прибавление к одной строке другой строки, умноженной на число: Прибавление к одному уравнению системы другого уравнения, умноженного на некоторое число.
Эти преобразования не меняют множество решений исходной системы, то есть приводят к эквивалентной системе.

2. Характеристика

Универсальность: Метод применим к любой СЛАУ, независимо от того, имеет ли она единственное решение, бесконечно много решений или не имеет решений вовсе. В процессе выполнения метода можно определить тип системы.
Прямой метод: Дает точное решение системы (в предположении отсутствия ошибок округления) за конечное число шагов.
Вычислительная сложность: Для системы из n уравнений с n неизвестными сложность метода Гаусса составляет примерно O(n³) арифметических операций. Это делает его достаточно эффективным для систем умеренного размера, но затратным для очень больших систем.
Численная устойчивость: Стандартный метод Гаусса может быть чувствителен к ошибкам округления, особенно если в качестве ведущих элементов (пивотов) на диагонали матрицы появляются нули или очень малые числа. Для повышения устойчивости используют модификации, такие как метод Гаусса с выбором главного элемента (частичный или полный пивотинг), где на каждом шаге выбирается наибольший по модулю элемент в столбце (или во всей оставшейся подматрице) в качестве ведущего, что требует дополнительных перестановок строк (и столбцов при полном пивотинге).
Многофункциональность: Помимо решения СЛАУ, алгоритм Гаусса лежит в основе методов для:
Нахождения определителя матрицы.
Нахождения обратной матрицы.
Определения ранга матрицы.
Приведения матрицы к ступенчатому виду.
3. Способ решения СЛАУ (Алгоритм)

Процесс решения методом Гаусса обычно делят на два этапа: прямой ход и обратный ход.

Этап 1: Прямой ход (Приведение к треугольному или ступенчатому виду)

Составить расширенную матрицу системы: Записать коэффициенты при неизвестных и свободные члены в виде матрицы [A|b].

Преобразовать матрицу к верхнетреугольному (или ступенчатому) виду:

Шаг 1: Работая с первым столбцом, выбрать ведущий элемент (обычно a₁₁). Если он равен нулю, поменять первую строку с другой строкой ниже, где элемент в первом столбце не равен нулю. Если все элементы первого столбца нулевые, перейти к следующему столбцу.
С помощью элементарных преобразований (прибавление первой строки, умноженной на подходящие коэффициенты, к нижележащим строкам) добиться того, чтобы все элементы под ведущим элементом в первом столбце стали равны нулю.
Шаг k: Перейти к k-му столбцу. Выбрать ведущий элемент a1..a2..a3..a4.. (на главной диагонали в k-й строке). Если он равен нулю, поменять k-ю строку с одной из нижележащих строк, где элемент в k-м столбце не равен нулю.
С помощью элементарных преобразований (прибавление k-й строки, умноженной на подходящие коэффициенты, к строкам (k+1), (k+2), ..., n) обнулить все элементы под ведущим элементом в k-м столбце.
Повторять процесс для всех столбцов (или пока не будут обработаны все строки).
В результате прямого хода расширенная матрица приводится к виду, где все элементы ниже главной диагонали матрицы коэффициентов равны нулю (верхнетреугольный вид) или к более общему ступенчатому виду.

Анализ полученной системы:

Если в процессе преобразований получена строка вида [0 0 ... 0 | c], где c ≠ 0, то система несовместна (не имеет решений).
Если система совместна и число ненулевых строк в ступенчатой матрице равно числу неизвестных, система имеет единственное решение.
Если система совместна и число ненулевых строк меньше числа неизвестных, система имеет бесконечно много решений (появятся свободные переменные).
Этап 2: Обратный ход (Нахождение неизвестных)

Записать эквивалентную систему: Переписать систему уравнений, соответствующую полученной треугольной (или ступенчатой) матрице.
Найти неизвестные:
Из последнего ненулевого уравнения (которое в случае единственного решения содержит только одну неизвестную x1..x2..x3..) найти значение этой неизвестной.
Подставить найденное значение x1..x2..x3 в предпоследнее уравнение и найти из него неизвестную x1..x2..x3..x₋₁.
Продолжать процесс подстановки найденных значений в предыдущие уравнения, двигаясь снизу вверх, пока не будут найдены все неизвестные (x1..x2..x3..x4.., x1..x2..x3..x₋₁, ..., x₂, x₁).
Если система имеет бесконечно много решений, то переменные, соответствующие столбцам без ведущих элементов (свободные переменные), можно выразить через параметры, а остальные переменные (базисные) выразить через эти параметры, используя обратный ход.</value>
  </data>
  <data name="SLAU_ITERATION" xml:space="preserve">
    <value>Метод Простой Итерации (Метод Якоби)

В отличие от прямых методов (Гаусса, Жордана-Гаусса), метод простой итерации является итерационным. Он не дает точное решение за конечное число шагов (в теории), а строит последовательность приближений, которая (при определенных условиях) сходится к точному решению.

Идея:

1. Преобразование системы: Исходную систему Ax = b преобразуют к эквивалентному виду x = Bx + g. Это стандартный шаг для многих итерационных методов. Для метода простой итерации (Якоби) это делается так:
Из i-го уравнения системы выражают переменную xᵢ через остальные: aᵢ₁x₁ + aᵢ₂x₂ + ... + aᵢᵢxᵢ + ... + aᵢ = bᵢ aᵢᵢxᵢ = bᵢ - (aᵢ₁x₁ + ... + aᵢ,ᵢ₋₁xᵢ₋₁ + aᵢ,ᵢ₊₁xᵢ₊₁ + ... + aᵢ ...) xᵢ = (1 / aᵢᵢ) * (bᵢ - Σ[j≠i] aᵢⱼxⱼ)
Это преобразование возможно, только если все диагональные элементы aᵢᵢ не равны нулю.
Итерационный процесс:

2. Выбирается начальное приближение x⁽⁰⁾ (часто нулевой вектор).
Последующие приближения вычисляются по формуле, полученной на шаге 1: xᵢ⁽ᵏ⁺¹⁾ = (1 / aᵢᵢ) * (bᵢ - Σ[j≠i] aᵢⱼxⱼ⁽ᵏ⁾) Здесь x⁽ᵏ⁾ - вектор приближения на k-й итерации, x⁽ᵏ⁺¹⁾ - на (k+1)-й. Важно, что для расчета всех компонент вектора x⁽ᵏ⁺¹⁾ используются значения только из предыдущего вектора x⁽ᵏ⁾.
Условие остановки: Итерации продолжаются до тех пор, пока разница между последовательными приближениями не станет достаточно малой (меньше заданной точности ε), или пока не будет достигнуто максимальное число итераций. Критерий остановки обычно выглядит как ||x⁽ᵏ⁺¹⁾ - x⁽ᵏ⁾|| &lt; ε, где ||...|| - некоторая норма вектора (например, максимальное абсолютное значение разности компонент).

Сходимость:
 - Метод сходится не для всех систем.
 - Достаточное условие сходимости: Строгое диагональное преобладание матрицы A. То есть, для каждой строки i модуль диагонального элемента |aᵢᵢ| должен быть больше суммы модулей всех остальных элементов в этой строке: |aᵢᵢ| &gt; Σ[j≠i] |aᵢⱼ|.
Если диагональные элементы малы или равны нулю, метод неприменим или требует предварительного преобразования системы (например, перестановки строк/столбцов).</value>
  </data>
  <data name="SLAU_JORDAN_GAUSS" xml:space="preserve">
    <value>Метод Жордана-Гаусса также используется для решения СЛАУ Ax = b. Его ключевое отличие от классического метода Гаусса заключается в том, что он приводит расширенную матрицу системы не просто к верхнетреугольному виду, а к приведенному ступенчатому виду (Reduced Row Echelon Form - RREF).

В RREF:

 - Все ненулевые строки находятся над нулевыми строками.
 - Ведущий элемент (первый ненулевой элемент, или "пивот") каждой ненулевой строки равен 1.
 - Ведущий элемент каждой строки находится правее ведущего элемента строки выше.
 - Каждый ведущий элемент (равный 1) является единственным ненулевым элементом в своем столбце.

Преимущество: После приведения матрицы [A|b] к виду [I|x'], где I — единичная матрица, столбец свободных членов x' напрямую содержит решение системы x. Этап обратного хода, как в методе Гаусса, здесь не требуется.

Недостаток: Обычно требует немного больше арифметических операций (примерно в 1.5 раза), чем классический метод Гаусса с обратным ходом, так как выполняется обнуление элементов не только под ведущими элементами, но и над ними.

Алгоритм:

1. Составить расширенную матрицу [A|b].
2. Пройти по столбцам матрицы A (слева направо). Для каждого столбца k:
 - Найти строку pivotRow (начиная с текущей основной строки и ниже) с максимальным по модулю элементом в столбце k (частичный пивотинг).
 - Если максимальный элемент близок к нулю, перейти к следующему столбцу k+1, не меняя номер основной строки (этот столбец не будет содержать ведущий элемент).
 - Поменять местами текущую основную строку и pivotRow.
3. Нормализовать основную строку: разделить все её элементы на значение ведущего элемента matrix[pivotRow, k], чтобы он стал равен 1.
4. бнулить все остальные элементы в столбце k: для каждой строки i (кроме основной pivotRow), вычесть из неё основную строку, умноженную на matrix[i, k]. Это делается как для строк ниже, так и для строк выше основной.
5. Перейти к следующей основной строке и следующему столбцу.
6. После завершения процесса (когда пройдены все столбцы или все строки использованы как основные):
 - Проверить на несовместность: если есть строки вида [0 0 ... 0 | c] с c ≠ 0, система несовместна.
 - Проверить на бесконечное число решений: если число ведущих элементов (пивотов) меньше числа неизвестных n и система совместна, то решений бесконечно много.
 - Если получена матрица вида [I | x'] (или [I' | x'], где I' - единичная матрица с возможными перестановками строк и добавлением нулевых строк), то вектор x' содержит единственное решение.
</value>
  </data>
  <data name="SLAU_ZAIDEL" xml:space="preserve">
    <value>Метод Зейделя также преобразует систему Ax = b к виду x = Bx + g и строит последовательность приближений x⁽⁰⁾, x⁽¹⁾, ..., x⁽ᵏ⁾, ... . Ключевое отличие от метода Якоби заключается в том, что при вычислении компоненты xᵢ⁽ᵏ⁺¹⁾ на шаге (k+1) используются уже вычисленные компоненты x₁⁽ᵏ⁺¹⁾, ..., xᵢ₋₁⁽ᵏ⁺¹⁾ из текущей итерации (k+1), а не только значения из предыдущей итерации (k).

Итерационная формула:

xᵢ⁽ᵏ⁺¹⁾ = (1 / aᵢᵢ) * (bᵢ - Σ[j&lt;i] aᵢⱼxⱼ⁽ᵏ⁺¹⁾ - Σ[j&gt;i] aᵢⱼxⱼ⁽ᵏ⁾)

Для j &lt; i, мы используем значения xⱼ, которые уже были обновлены на текущем шаге k+1.
Для j &gt; i, мы используем значения xⱼ из предыдущего шага k.

Преимущество в реализации:
Это позволяет обновлять вектор решения x "на месте" (in-place), без необходимости хранить полную копию вектора предыдущей итерации (x_new в реализации Якоби) во время вычисления суммы. Однако для проверки сходимости нам все равно нужно сравнить вектор x в конце итерации с вектором x в начале итерации.

Сходимость:
 - Как и для метода Якоби, строгое диагональное преобладание матрицы A является достаточным условием сходимости.
 - Если метод Зейделя сходится, то, как правило, он сходится быстрее метода Якоби (примерно в два раза).
 - Однако существуют системы, для которых Якоби сходится, а Зейдель — нет, и наоборот.
 - Условие сходимости (спектральный радиус матрицы итераций &lt; 1) немного отличается от Якоби.

Алгоритм:

1. Проверить систему на наличие ненулевых диагональных элементов aᵢᵢ. Опционально проверить диагональное преобладание.
2. Выбрать начальное приближение x⁽⁰⁾ (часто нулевой вектор).
3. Задать точность ε и максимальное число итераций maxIterations.
4. Начать итерационный цикл (от k = 0 до maxIterations - 1): a. Сохранить текущее приближение x в x_old. b. Для каждого i от 0 до n-1: i. Вычислить сумму sum = Σ[j≠i] aᵢⱼxⱼ, используя текущие значения в векторе x. (Так как x[0]..x[i-1] уже обновлены на шаге k+1, а x[i+1]..x[n-1] еще с шага k, это автоматически соответствует формуле Зейделя). ii. Обновить x[i] = (bᵢ - sum) / aᵢᵢ. c. Вычислить максимальную разницу между x (новым) и x_old (старым): maxDiff = ||x - x_old||. d. Если maxDiff &lt; ε, то решение найдено, вернуть x.
5. Если цикл завершен без достижения нужной точности, вернуть null.
</value>
  </data>
</root>