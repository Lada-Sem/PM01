//------------------------------------------------------------------------------
// <auto-generated>
//     Этот код создан программой.
//     Исполняемая версия:4.0.30319.42000
//
//     Изменения в этом файле могут привести к неправильной работе и будут потеряны в случае
//     повторной генерации кода.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Grapher.Properties {
    using System;
    
    
    /// <summary>
    ///   Класс ресурса со строгой типизацией для поиска локализованных строк и т.д.
    /// </summary>
    // Этот класс создан автоматически классом StronglyTypedResourceBuilder
    // с помощью такого средства, как ResGen или Visual Studio.
    // Чтобы добавить или удалить член, измените файл .ResX и снова запустите ResGen
    // с параметром /str или перестройте свой проект VS.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Возвращает кэшированный экземпляр ResourceManager, использованный этим классом.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Grapher.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Перезаписывает свойство CurrentUICulture текущего потока для всех
        ///   обращений к ресурсу с помощью этого класса ресурса со строгой типизацией.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Ищет локализованную строку, похожую на Название программы: Grapher (исследователь функций)
        ///Версия: 1.0.0
        ///
        ///Это приложение предназначено для выполнения
        ///математических расчетов и визуализации графиков.
        ///Вы можете использовать его для анализа функций и
        ///получения различных решений.
        ///
        ///Разработано студенткой группы 21 П-1,
        ///Семакиной Ладой Владиславовной.
        ///
        ///Все права защищены.
        ///2024 г..
        /// </summary>
        internal static string Manifest {
            get {
                return ResourceManager.GetString("Manifest", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Ищет локализованную строку, похожую на Многошаговые Методы (Методы Адамса)
        ///
        ///Идея:
        ///
        ///В отличие от одношаговых методов (Эйлер, Рунге-Кутта), которые для вычисления yᵢ₊₁ используют информацию только из предыдущей точки (xᵢ, yᵢ), многошаговые методы используют значения решения y и/или его производной f в нескольких предыдущих точках (yᵢ, yᵢ₋₁, yᵢ₋₂, ... и fᵢ, fᵢ₋₁, fᵢ₋₂, ...). Они основаны на идее аппроксимации интеграла ∫ f(x, y) dx с помощью интерполяционного полинома, построенного по предыдущим значениям f.
        ///
        ///Типы Методов Адамса:
        ///
        ///Методы Ад [остаток строки не уместился]&quot;;.
        /// </summary>
        internal static string ODU_ADAMS {
            get {
                return ResourceManager.GetString("ODU_ADAMS", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Ищет локализованную строку, похожую на Методы Эйлера (явный, неявный, модифицированный)
        ///При заданном начальном условии y(x₀) = y₀. Цель — найти приближенное значение функции y(x) в последующих точках x₁, x₂, ....
        ///
        ///1. Явный (Прямой) Метод Эйлера
        ///
        ///Идея: Самый простой метод. Мы используем значение производной f(x, y) в начале текущего шага xᵢ, чтобы экстраполировать значение y на следующем шаге xᵢ₊₁.
        ///
        ///Формула: yᵢ₊₁ = yᵢ + h * f(xᵢ, yᵢ) где h = xᵢ₊₁ - xᵢ — размер шага.
        ///
        ///Характеристики:
        /// - Прост в реализации.
        /// - Метод первого порядка точно [остаток строки не уместился]&quot;;.
        /// </summary>
        internal static string ODU_AILER {
            get {
                return ResourceManager.GetString("ODU_AILER", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Ищет локализованную строку, похожую на Как и в случае с методами Эйлера, методы Рунге-Кутты предназначены для численного решения обыкновенных дифференциальных уравнений (ОДУ) вида dy/dx = f(x, y) с начальным условием y(x₀) = y₀, а не для численного дифференцирования (нахождения производной).
        ///
        ///Методы Рунге-Кутты — это целое семейство итерационных методов для решения ОДУ, которые стремятся достичь более высокой точности по сравнению с методами Эйлера за счет вычисления значения функции f(x, y) в нескольких промежуточных точках внутри одного шага [остаток строки не уместился]&quot;;.
        /// </summary>
        internal static string ODU_RK {
            get {
                return ResourceManager.GetString("ODU_RK", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Ищет локализованную строку, похожую на Метод Гаусса — это классический и один из самых универсальных прямых методов решения СЛАУ вида Ax = b, где A — матрица коэффициентов системы, x — вектор неизвестных, а b — вектор свободных членов.
        ///
        ///Суть метода заключается в последовательном исключении неизвестных из уравнений системы с помощью элементарных преобразований над строками расширенной матрицы системы. Цель — привести исходную систему к эквивалентной системе с матрицей более простого вида (обычно треугольной или ступенчатой), из которой неизвест [остаток строки не уместился]&quot;;.
        /// </summary>
        internal static string SLAU_GAUSS {
            get {
                return ResourceManager.GetString("SLAU_GAUSS", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Ищет локализованную строку, похожую на Метод Простой Итерации (Метод Якоби)
        ///
        ///В отличие от прямых методов (Гаусса, Жордана-Гаусса), метод простой итерации является итерационным. Он не дает точное решение за конечное число шагов (в теории), а строит последовательность приближений, которая (при определенных условиях) сходится к точному решению.
        ///
        ///Идея:
        ///
        ///1. Преобразование системы: Исходную систему Ax = b преобразуют к эквивалентному виду x = Bx + g. Это стандартный шаг для многих итерационных методов. Для метода простой итерации (Якоби) это дел [остаток строки не уместился]&quot;;.
        /// </summary>
        internal static string SLAU_ITERATION {
            get {
                return ResourceManager.GetString("SLAU_ITERATION", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Ищет локализованную строку, похожую на Метод Жордана-Гаусса также используется для решения СЛАУ Ax = b. Его ключевое отличие от классического метода Гаусса заключается в том, что он приводит расширенную матрицу системы не просто к верхнетреугольному виду, а к приведенному ступенчатому виду (Reduced Row Echelon Form - RREF).
        ///
        ///В RREF:
        ///
        /// - Все ненулевые строки находятся над нулевыми строками.
        /// - Ведущий элемент (первый ненулевой элемент, или &quot;пивот&quot;) каждой ненулевой строки равен 1.
        /// - Ведущий элемент каждой строки находится правее ведущего э [остаток строки не уместился]&quot;;.
        /// </summary>
        internal static string SLAU_JORDAN_GAUSS {
            get {
                return ResourceManager.GetString("SLAU_JORDAN_GAUSS", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Ищет локализованную строку, похожую на Метод Зейделя также преобразует систему Ax = b к виду x = Bx + g и строит последовательность приближений x⁽⁰⁾, x⁽¹⁾, ..., x⁽ᵏ⁾, ... . Ключевое отличие от метода Якоби заключается в том, что при вычислении компоненты xᵢ⁽ᵏ⁺¹⁾ на шаге (k+1) используются уже вычисленные компоненты x₁⁽ᵏ⁺¹⁾, ..., xᵢ₋₁⁽ᵏ⁺¹⁾ из текущей итерации (k+1), а не только значения из предыдущей итерации (k).
        ///
        ///Итерационная формула:
        ///
        ///xᵢ⁽ᵏ⁺¹⁾ = (1 / aᵢᵢ) * (bᵢ - Σ[j&lt;i] aᵢⱼxⱼ⁽ᵏ⁺¹⁾ - Σ[j&gt;i] aᵢⱼxⱼ⁽ᵏ⁾)
        ///
        ///Для j &lt; i, мы используем значения xⱼ,  [остаток строки не уместился]&quot;;.
        /// </summary>
        internal static string SLAU_ZAIDEL {
            get {
                return ResourceManager.GetString("SLAU_ZAIDEL", resourceCulture);
            }
        }
    }
}
